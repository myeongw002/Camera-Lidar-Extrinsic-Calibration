def find_largest_quadrilateral(points):
    """
    Convex Hull에서 4개의 점을 선택하여 가장 넓은 사각형을 찾는 함수
    Args:
        points (numpy array): (N, 2) 형태의 Convex Hull 점들
    Returns:
        best_quad (numpy array): 가장 넓은 4개의 점 (4, 2) 형태
    """
    max_area = 0
    best_quad = None
    
    # Convex Hull 점들 중 4개를 조합하여 모든 경우 확인
    for quad in itertools.combinations(points, 4):
        quad = np.array(quad)  # 리스트를 numpy array로 변환
        
        # Convex Hull을 이용해 넓이 계산
        hull = cv2.convexHull(quad)
        area = cv2.contourArea(hull)

        if area > max_area:
            max_area = area
            best_quad = quad
    
    return best_quad  # (4, 2) 형태의 좌표 반환


def nearest_corner(quad_pts, corner_pts):
    """
    가장 넓은 Convex Hull 4점과 체스보드 코너점 중 가장 가까운 점 찾기
    Args:
        quad_pts: (4,2) 형태의 Convex Hull 점들
        corner_pts: (N,2) 형태의 체스보드 코너점들
    Returns:
        matched_pts: quad_pts에 대해 대응하는 corner_pts
    """
    matched_pts = []
    
    for quad_pt in quad_pts:
        dists = np.linalg.norm(corner_pts - quad_pt, axis=1)  # 유클리드 거리 계산
        nearest_idx = np.argmin(dists)  # 가장 가까운 코너 인덱스 찾기
        matched_pts.append(corner_pts[nearest_idx])  # 대응 코너 저장
    
    return np.array(matched_pts)  # (4,2) 형태

def reprojection_error(params, pcd_list, corner_list, intrinsic, distortion, image_T_list):
    residuals = []
    for pcd_pts, corner_pts, image_T in zip(pcd_list, corner_list, image_T_list):
        # params: 6차원 extrinsic 파라미터 (회전, 이동)
        rvec = params[:3].reshape(3,1)
        tvec = params[3:6].reshape(3,1)

        image_R = image_T[:3,:3]
        image_rvec = cv2.Rodrigues(image_R)[0]
        image_tvec = image_T[:3,3].reshape(3,1)
        
        # LiDAR 포인트 클라우드 투영
        pcd_np = np.asarray(pcd_pts.points)
        projected_pcd, _ = cv2.projectPoints(pcd_np, rvec, tvec, intrinsic, distortion)
        projected_pcd = projected_pcd.reshape(-1,2)  # (N,1,2) → (N,2)
        
        # 체스보드 코너 투영
        projected_corner, _ = cv2.projectPoints(corner_pts, image_rvec, image_tvec, intrinsic, distortion)
        projected_corner = projected_corner.reshape(-1,2)

        # LiDAR Convex Hull & 체스보드 가장 넓은 4점 찾기
        hull = cv2.convexHull(projected_pcd.astype(np.float32)).reshape(-1,2)
        quad_pts = find_largest_quadrilateral(hull)

        # Convex Hull의 4개 점과 가장 가까운 체스보드 코너 찾기
        matched_pts = nearest_corner(quad_pts, projected_corner)

        # Residuals 계산 (오차 = 대응점 간 거리)
        distances = np.linalg.norm(matched_pts - quad_pts, axis=1)
        residuals.extend(distances)
    
    return np.array(residuals)  # 최적화할 오차 배열